# K-Means-and-Auto-Encoder
The task of the project is to perform unsupervised learning on Cifar 10 dataset. There are two task, the first is to perform K-means clustering on the raw data from scratch. The second is to perform K-means clustering on a representation generated by the Auto-Encoder method using library functions. The code should be written in Python using Keras.

The Cifar 10 dataset has a training set of 50,000 examples, and a test set of 10,000 examples. Each example is a 32x32 image, associated with a label from 10 classes. Each image is 32 pixels in height and 32 pixels in width, for a total of 1024 pixels in total. This pixel-value is an integer between 0 and 255. The training and test data sets have 1025 columns including the labels.

# 1.1 Implement K-Means Clustering
We will first load the cifar10 dataset and store the test and train data.

<img width="650" alt="1_1" src="https://user-images.githubusercontent.com/52970601/150615915-cba14094-faa2-472a-a005-97b46276e65d.png">

Next we will converts the images from RGB to Grayscale. The size of the last dimension becomes 1, containing the Grayscale value of the pixels.

<img width="650" alt="1_2" src="https://user-images.githubusercontent.com/52970601/150615961-d6d5e568-8f6a-4ec2-beca-9a59f23034ed.png">

To avoid making the computation more complex we will normalize the values to range 0 to 1. This is done by dividing the data by 255 (since the pixels range is 255).

<img width="400" alt="1_3" src="https://user-images.githubusercontent.com/52970601/150615983-19d7cebc-012b-4977-bdff-5981a21e1d30.png">

Now we will reshape the images from a square of 32 X 32 pixels to 1024.

<img width="650" alt="1_4" src="https://user-images.githubusercontent.com/52970601/150616000-87505851-8a79-4afa-a5ae-0d06a05d268a.png">

We will define 10 clusters and then initialize random centroids.

<img width="650" alt="1_5" src="https://user-images.githubusercontent.com/52970601/150616065-84ef5103-759b-4f9f-bab3-27041536a541.png">

<img width="650" alt="1_6" src="https://user-images.githubusercontent.com/52970601/150616075-a374b7a7-f897-4fe8-849e-4c63c15f2b17.png">

The next step is to define methods for updating and forming clusters.

<img width="650" alt="1_7" src="https://user-images.githubusercontent.com/52970601/150616120-5d188d68-b243-4b68-9631-0a3cc55d4ba6.png">

We will now calculate the difference between the old and the new centroids. Until the difference is the least we will keep updating our centroids and form clusters with those updated centroids.

<img width="650" alt="1_81" src="https://user-images.githubusercontent.com/52970601/150616222-6f139b1f-b410-4b29-8e72-ddf3c433399f.png">

Now we will access the quality of the clusters using ASC (Average Silhouette Coefficient) and DI (Dunn’s Index) evaluation metrics.

<img width="650" alt="1_8" src="https://user-images.githubusercontent.com/52970601/150616268-a81892d1-995a-4337-ad51-3c20ac7bf687.png">

For Dunn’s Index, I installed the validclust package separately.

<img width="650" alt="1_82" src="https://user-images.githubusercontent.com/52970601/150616296-73433082-00c5-4df4-bc24-e326325da9d0.png">

<img width="650" alt="1_9" src="https://user-images.githubusercontent.com/52970601/150616323-5c684ce8-ab0b-46fd-8c0f-a036dcb2008d.png">

# 1.2 Implement Auto-Encoder
The general idea of Auto-Encoders is that we have to set an encoder and a decoder as neural networks and to learn the best encoding-decoding scheme using an iterative optimisation process. So, at each iteration we feed the autoencoder architecture (the encoder followed by the decoder) with some data, we compare the encoded-decoded output with the initial data and back-propagate the error through the architecture to update the weights of the networks.

<img width="650" alt="2_1" src="https://user-images.githubusercontent.com/52970601/150616373-6b3f047b-4f7b-453c-8209-3bef2189c594.png">

Here we have used encoder with two dense layers. One with 1024 for which we have flattened the x train data and then the other with 64.
We will then define encoder model. This model will be further used for predicting the x train data.
Similarly we have defined for the decoder part but in a reverse manner. That is the first layer has 64 then 1024.

<img width="650" alt="2_2" src="https://user-images.githubusercontent.com/52970601/150616415-564c2af5-8891-479c-917c-2a1a12549a18.png">

We will then compile and fit our AutoEncoder Model using Adam optimizer and loss =’mse’.

<img width="650" alt="2_3" src="https://user-images.githubusercontent.com/52970601/150616433-de01998c-f680-47e7-bc72-8c1d5c90c0ea.png">

Now using the Encoder model defined previously we will predict the x train data. Using K-Mean we generate clusters from the sparse representations generated by the Auto-Encoders.

<img width="650" alt="2_4" src="https://user-images.githubusercontent.com/52970601/150616465-6774101d-4770-4a6c-aff4-d0f6b097d112.png">

Lastly we will access the quality of the clusters using ASC (Average Silhouette Coefficient).

<img width="650" alt="2_5" src="https://user-images.githubusercontent.com/52970601/150616501-67c57c97-f5a6-41e6-b279-c2e0e3026bec.png">

